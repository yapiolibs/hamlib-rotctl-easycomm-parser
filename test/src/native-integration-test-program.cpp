#if defined(ENV_NATIVE)
#include <easycomm-buffered-tokenizer.h>
#include <easycomm-command-callback-handler.h>
#include <easycomm-parser-types-sprintf.h>
#include <easycomm-response-types-ctors.h>
#include <easycomm-response-types-sprintf.h>
#include <easycomm-response-types.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sys/select.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

extern const char *__progname;

/**
 * This test program runs natively for integration testing.
 * It reads input from a file descriptor to feed the easycomm-parser with data generated by rotctl.
 * Prints the parsed command to stdout or "<invalid>" if cannot parse.
 * Writes some more data into a log file named <__progname>.log in the current working directory.
 *
 * Integration testing workflow:
 *   1. create a virtual device:
 *      socat -d -d pty,raw,echo=0,link=/tmp/easycomm-host-side pty,raw,echo=0,link=/tmp/easycomm-controller-side
 *
 *   2. start rotctl:
 *      rotctl --model=204 --rot-file=/tmp/easycomm-host-side -vvvvv
 *
 *   3. start test program (build with `pio run -e native`):
 *      pio run -e native
 *      .pio/build/native/program /tmp/easycomm-controller-side
 *
 *   4. send commands from rotctl and verify the output of the test program
 *      the command "R" or "\reset" indicates the program to terminate
 */

// -------------------------------------------------------------------------------------------------

typedef struct CallbackData
{
    std::string retained_response{};
    size_t num_commands_pending{ 0 };
    int serial_fd{ -1 };
    FILE *log_file{ nullptr };
} CallbackData;

// -------------------------------------------------------------------------------------------------

static void printResponse(const EasycommData *command, void *custom_data)
{
    CallbackData *data = (CallbackData *)custom_data;
    if(data->num_commands_pending == 0)
    {
        printf("unexpected number of commands");
        exit(1);
    }

    data->num_commands_pending--;
    char string_buffer[128] = { 0 };

    easycommDataSprintf(command, string_buffer);
    printf("received: >%s<\n", string_buffer);
    fprintf(data->log_file, "      parsed: >%s<\n", string_buffer);

    if(EasycommIdDoReset == command->commandId)
    {
        if(0 != close(data->serial_fd))
        {
            fprintf(data->log_file, "failed to close serial device; %s (error %d)", strerror(errno), errno);
        }
        fprintf(data->log_file, "<< exit  PID=%d\n", getpid());
        fflush(data->log_file);
        fclose(data->log_file);
        fflush(stdout);
        exit(0);
    }
    else if(command->commandId == EasycommIdGetAzimuth)
    {
        EasycommResponseAzimuth r;
        easycommResponseAzimuth(&r);
        r.azimuth = 11;
        easycommResponseAzimuthSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetElevation)
    {
        EasycommResponseElevation r;
        easycommResponseElevation(&r);
        r.elevation = 12;
        easycommResponseElevationSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetUplinkFrequency)
    {
        EasycommResponseUplinkFrequency r;
        easycommResponseUplinkFrequency(&r);
        r.frequency.as.uint32 = 30000000;
        easycommResponseUplinkFrequencySprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetDownlinkFrequency)
    {
        EasycommResponseDownlinkFrequency r;
        easycommResponseDownlinkFrequency(&r);
        r.frequency.as.uint32 = 29000000;
        easycommResponseDownlinkFrequencySprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetUplinkMode)
    {
        EasycommResponseUplinkMode r;
        easycommResponseUplinkMode(&r);
        memcpy(&r.mode, "CW", 2);
        easycommResponseUplinkModeSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetDownlinkMode)
    {
        EasycommResponseDownlinkMode r;
        easycommResponseDownlinkMode(&r);
        memcpy(&r.mode, "USB", 3);
        easycommResponseDownlinkModeSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetUplinkRadio)
    {
        EasycommResponseUplinkRadio r;
        easycommResponseUplinkRadio(&r);
        r.number = 1;
        easycommResponseUplinkRadioSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetDownlinkRadio)
    {
        EasycommResponseDownlinkRadio r;
        easycommResponseDownlinkRadio(&r);
        r.number = 2;
        easycommResponseDownlinkRadioSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetTime)
    {
        EasycommResponseTime r;
        easycommResponseTime(&r);
        r.year = 70;
        r.month = 1;
        r.day = 1;
        r.hour = 23;
        r.minute = 59;
        r.second = 59;
        easycommResponseTimeSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetStatusRegister)
    {
        EasycommResponseStatusRegister r;
        easycommResponseStatusRegister(&r);
        r.status = EasycommStatusMoving;
        easycommResponseStatusRegisterSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetErrorRegister)
    {
        EasycommResponseErrorRegister r;
        easycommResponseErrorRegister(&r);
        r.status = EasycommErrorSensor;
        easycommResponseErrorRegisterSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetDigitalInput)
    {
        EasycommResponseDigitalInput r;
        easycommResponseDigitalInput(&r);
        r.number = 1;
        r.value = true;
        easycommResponseDigitalInputSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetAnalogueInput)
    {
        EasycommResponseAnalogueInput r;
        easycommResponseAnalogueInput(&r);
        r.number = 1;
        r.value = 42;
        easycommResponseAnalogueInputSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetVersion)
    {
        EasycommResponseVersion r;
        easycommResponseVersion(&r);
        r.major = 0;
        r.minor = 1;
        easycommResponseVersionSprintf(&r, string_buffer);
    }
    else if(command->commandId == EasycommIdGetConfigRegister)
    {
        EasycommResponseConfigRegister r;
        easycommResponseConfigRegister(&r);
        r.registerNumber = 1;
        memcpy(&r.value.as.str, "asdf", 4);
        easycommResponseConfigRegisterSprintf(&r, string_buffer);
    }
    else
        return;

    if(data->num_commands_pending == 0)
    {
        data->retained_response.append(string_buffer);
        fprintf(data->log_file, "      response: >%s<\n", data->retained_response.c_str());
        printf("response: >%s<\n", data->retained_response.c_str());
        (void)write(data->serial_fd, data->retained_response.c_str(), data->retained_response.length());
        (void)write(data->serial_fd, "\n", 1);
        fflush(data->log_file);
        fflush(stdout);
        data->retained_response.clear();
    }
    else
    {
        data->retained_response.append(string_buffer);
        data->retained_response.append(" ");
    }
}

// -------------------------------------------------------------------------------------------------

int main(int argc, const char **argv)
{
    CallbackData cb_data;

    { // open log file
        char log_file_name[128] = { 0 };
        sprintf(log_file_name, "%s.log", __progname);
        cb_data.log_file = fopen(log_file_name, "a");
        if(nullptr == cb_data.log_file)
        {
            printf("failed to open logfile: \"%s\"", log_file_name);
            fflush(stdout);
            return 1;
        }
        fprintf(cb_data.log_file, ">> start PID=%d\n", getpid());
        fflush(cb_data.log_file);
    }

    if(argc < 2) // check cli arguments
    {
        printf("not enough arguments provided: serial device path missing\n");
        fprintf(cb_data.log_file, "not enough arguments provided: serial device path missing\n");
        fflush(stdout);
        fflush(cb_data.log_file);
        fclose(cb_data.log_file);
        return 1;
    }

    { // open serial device
        const char *device_path = argv[1];
        cb_data.serial_fd = open(device_path, O_RDWR);
        for(int8_t retries = 16; (retries > 0) && (cb_data.serial_fd < 0); retries--)
        {
            timeval timeout{ .tv_sec = 0, .tv_usec = 125 * 1000 };
            select(0, nullptr, nullptr, nullptr, &timeout);
            cb_data.serial_fd = open(device_path, O_RDWR);
            if(cb_data.serial_fd < 0)
            {
                printf("failed to open device %s: %s (error %d), retries: %d", device_path,
                       strerror(errno), errno, retries);
                fprintf(cb_data.log_file, "failed to open device %s: %s (error %d), retries: %d",
                        device_path, strerror(errno), errno, retries);
            }
        }

        if(cb_data.serial_fd < 0)
        {
            printf("failed to open device %s: %s (error %d)", device_path, strerror(errno), errno);
            fprintf(cb_data.log_file, "failed to open device %s: %s (error %d)", device_path,
                    strerror(errno), errno);
            fflush(stdout);
            fflush(cb_data.log_file);
            fclose(cb_data.log_file);
            return 1;
        }
    }


    EasycommCommandsCallback cb_handler;
    easycommCommandsCallbackCustomDefaultCb(&cb_handler, EasycommParserStandard123, printResponse);

    EasycommBufferedTokenizerState line_token_state;
    easycommBufferedTokenizerState(&line_token_state);
    char line_token_buffer[128] = { 0 };
    easycommBufferedTokenizerStateSetBuffers(&line_token_state, line_token_buffer, sizeof(line_token_buffer));

    while(true) // read bytes from serial device
    {
        char line_buffer[256] = { 0 };
        fd_set read_fds;
        fd_set exception_fds;
        FD_SET(cb_data.serial_fd, &read_fds);
        FD_SET(cb_data.serial_fd, &exception_fds);

        fprintf(cb_data.log_file, "  waiting ...\n");
        if(0 > select(cb_data.serial_fd + 1, &read_fds, nullptr, &exception_fds, nullptr))
        {
            printf("error: device not ready: %s (error %d)\n", strerror(errno), errno);
            fprintf(cb_data.log_file, "error: device not ready: %s (error %d)\n", strerror(errno), errno);
        }

        // assume:
        //   - a read may contain multiple lines of 1 to N commands
        //   - a line terminates with '\n' or "\r\n"
        //   - a line may have leading/trailing ' ' around '\n' or "\r\n"
        //   - multiple commands in a line are separated by one or multiple ' '
        ssize_t read_len = read(cb_data.serial_fd, &line_buffer[0], sizeof(line_buffer));
        if(0 > read_len)
        {
            printf("error: failed to read stdin: %s (error %d)\n", strerror(errno), errno);
            fprintf(cb_data.log_file, "error: failed to read stdin: %s (error %d)\n", strerror(errno), errno);
            fflush(stdout);
            fflush(cb_data.log_file);
            fclose(cb_data.log_file);
            return 1;
        }
        else if(0 == read_len)
        {
            printf("error: unexpected read of 0 bytes\n");
            fprintf(cb_data.log_file, "error: unexpected read of 0 bytes\n");
            fflush(stdout);
            fflush(cb_data.log_file);
            fclose(cb_data.log_file);
            return 1;
        }
        else
        { // tokenize lines
            fprintf(cb_data.log_file, "  received >%s<\n", line_buffer);
            fflush(cb_data.log_file);

            // assume:
            //   - each command is space separated or ends with newline
            //   - due to rx-timeout rotctl expects exactly one answer for all commands in
            //     each line until '\n'r

            char *line_buffer_ptr = line_buffer;
            while(easycommBufferedTokenizerStrtok(&line_token_state, line_buffer_ptr, read_len))
            {
                line_buffer_ptr = nullptr;
                if(1 == line_token_state.has_token)
                {
                    // remember how many responses are to be retained; last response appends '\n'
                    cb_data.num_commands_pending = 1;
                    for(char *c = line_token_state.token; *c != 0; c++)
                        if(*c == ' ')
                            cb_data.num_commands_pending++;

                    char *save_ptr = nullptr;
                    char *word_token = strtok_r(line_token_state.token, " ", &save_ptr);
                    while(nullptr != word_token) // tokenize words
                    {
                        fprintf(cb_data.log_file, "    token >%s<, pending %zu\n", word_token,
                                cb_data.num_commands_pending);
                        easycommHandleCommand(word_token, &cb_handler, EasycommParserStandard123, &cb_data);
                        word_token = strtok_r(nullptr, " ", &save_ptr);
                    }
                    fprintf(cb_data.log_file, "  pending %zu\n", cb_data.num_commands_pending);

                    line_token_state.token_consumed = 1;
                }
            }
        }
    }
    return 0;
}
#endif
